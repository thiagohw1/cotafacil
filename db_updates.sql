DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'quote_responses' AND column_name = 'pricing_tiers') THEN
        ALTER TABLE quote_responses ADD COLUMN pricing_tiers JSONB DEFAULT '[]'::jsonb;
    END IF;
END $$;

-- Update the save_supplier_response RPC to handle pricing_tiers and allow updates after submission
CREATE OR REPLACE FUNCTION save_supplier_response(
  p_token text,
  p_quote_item_id integer,
  p_price numeric,
  p_min_qty numeric,
  p_delivery_days integer,
  p_notes text,
  p_pricing_tiers jsonb DEFAULT NULL
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
  v_quote_supplier_id integer;
  v_quote_id integer;
BEGIN
  -- Validate token and get quote_supplier_id and quote_id
  -- Allow updates if quote is open, even if already submitted
  SELECT qs.id, qs.quote_id INTO v_quote_supplier_id, v_quote_id
  FROM quote_suppliers qs
  JOIN quotes q ON q.id = qs.quote_id
  WHERE qs.public_token = p_token
    AND q.status = 'open'
    AND (q.deadline_at IS NULL OR q.deadline_at > NOW());

  IF v_quote_supplier_id IS NULL THEN
    RETURN false;
  END IF;

  -- Insert or Update response
  INSERT INTO quote_responses (
    quote_supplier_id,
    quote_id,
    quote_item_id,
    price,
    min_qty,
    delivery_days,
    notes,
    pricing_tiers,
    filled_at
  )
  VALUES (
    v_quote_supplier_id,
    v_quote_id,
    p_quote_item_id,
    p_price,
    p_min_qty,
    p_delivery_days,
    p_notes,
    COALESCE(p_pricing_tiers, '[]'::jsonb),
    NOW()
  )
  ON CONFLICT (quote_supplier_id, quote_item_id)
  DO UPDATE SET
    price = EXCLUDED.price,
    min_qty = EXCLUDED.min_qty,
    delivery_days = COALESCE(EXCLUDED.delivery_days, quote_responses.delivery_days),
    notes = EXCLUDED.notes,
    pricing_tiers = COALESCE(EXCLUDED.pricing_tiers, quote_responses.pricing_tiers),
    filled_at = NOW();

  -- Update status to 'viewed' if currently 'invited'
  UPDATE quote_suppliers
  SET status = 'viewed'
  WHERE id = v_quote_supplier_id
  AND status = 'invited';

  RETURN true;
END;
$function$;

-- Update submit_supplier_quote to allow resubmission
CREATE OR REPLACE FUNCTION submit_supplier_quote(p_token text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $function$
DECLARE
  v_quote_supplier_id integer;
BEGIN
  -- Validate token and get ID
  -- Allow resubmission if quote is open
  SELECT qs.id INTO v_quote_supplier_id
  FROM quote_suppliers qs
  JOIN quotes q ON q.id = qs.quote_id
  WHERE qs.public_token = p_token
    AND q.status = 'open'
    AND (q.deadline_at IS NULL OR q.deadline_at > NOW());
  
  IF v_quote_supplier_id IS NULL THEN
    RETURN FALSE;
  END IF;

  -- Mark as submitted (update timestamp)
  UPDATE quote_suppliers
  SET status = 'submitted', submitted_at = NOW(), last_access_at = NOW()
  WHERE id = v_quote_supplier_id;

  RETURN TRUE;
END;
$function$;


-- Create notifications table
CREATE TABLE IF NOT EXISTS notifications (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users NOT NULL,
  tenant_id bigint REFERENCES tenants(id) NOT NULL,
  title text NOT NULL,
  message text NOT NULL,
  link text,
  is_read boolean DEFAULT false,
  created_at timestamptz DEFAULT now()
);

-- Add RLS policies
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own notifications"
  ON notifications FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Users can update their own notifications"
  ON notifications FOR UPDATE
  USING (auth.uid() = user_id);
